#version 450 core

#define _NBL_GLSL_WORKGROUP_SIZE_ 64u

layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;


// #include <nbl/builtin/glsl/workgroup/arithmetic.glsl>
shared float scratchShared[64];

// This should most likely be a sampler
layout (set = 0, binding = 0, r32f) uniform readonly image1D inImage;
layout (set = 0, binding = 1, r32f) uniform writeonly image1D outImage;

#if 0
// Todo(achal): std140??
layout (set = 0, binding = 2) uniform Weights
{
	uvec2 data[];
} weights;
#endif

void main()
{
	// assuming downscale ALWAYS, for now
	const uint inWidth = 8u;
	const uint outWidth = 4u;
	const float scale = float(inWidth)/float(outWidth);

	const float weight = 1.f/scale;
	const vec2 support = vec2(-0.5f*scale, 0.5f*scale);
	const float windowSize = ceil(support[1] - support[0]); // this should correspond to WG_DIM

	// all the invocations I'm sending needs to be divided up into spans, such that one span covers the operating area of a Kogge-Stone Adder

	const uint spanWidth = uint(windowSize);
	const uint spansPerWG = _NBL_GLSL_WORKGROUP_SIZE_/spanWidth;

	if (gl_GlobalInvocationID.x < inWidth)
		scratchShared[gl_LocalInvocationIndex] = imageLoad(inImage, int(gl_GlobalInvocationID.x)).r;
	barrier();

	// Todo(achal): Gotta be careful here when spanWidth becomes 1 or 0
	const uint stepPerSpanCount = uint(ceil(log2(float(spanWidth))));
	const uint spanIndex = gl_LocalInvocationIndex/spanWidth;
	for (uint step = 0u; step < stepPerSpanCount; ++step)
	{
		const uint offset = (1 << step);
		const uint baseIndex = (1 << (step+1))*(gl_LocalInvocationIndex % spanWidth);

		if (baseIndex < spanWidth)
		{
			float addend = 0.f;
			if (baseIndex + offset < spanWidth)
				addend = scratchShared[spanWidth*spanIndex + (baseIndex + offset)];

			scratchShared[spanWidth*spanIndex + baseIndex] = weight * scratchShared[spanWidth*spanIndex + baseIndex] + weight * addend;
		}
		barrier();
	}

	// elect one invocation from a span to write to the output image
	if ((gl_LocalInvocationIndex % spanWidth) == 0u)
		imageStore(outImage, int(spanIndex), vec4(scratchShared[gl_LocalInvocationIndex], 0.f, 0.f, 0.f));
}