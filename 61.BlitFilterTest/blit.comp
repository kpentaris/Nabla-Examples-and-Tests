#version 450 core

layout(push_constant) uniform Block
{
	uint inWidth;
	uint outWidth;
} pc;


layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;

#define MAX_SMEM_SIZE (16*1024)

// Todo(achal): This should probably be a vec4
// arbitrary smem sizes
shared float preloadedInputPixels[MAX_SMEM_SIZE/8];
shared float scratchShared[MAX_SMEM_SIZE/8];

// This should most likely be a sampler
layout (set = 0, binding = 0) uniform sampler1D inImage;
layout (set = 0, binding = 1, r32f) uniform writeonly image1D outImage;

#if 0
// Todo(achal): std140??
layout (set = 0, binding = 2) uniform Weights
{
	uvec2 data[];
} weights;
#endif

// takes in input space pixel centers
int getWindowMinCoord(in float p, in float negativeSupport)
{
	return int(ceil( (p-0.5f)-abs(negativeSupport) ));
}

// takes in input space pixel centers
int getWindowMaxCoord(in float p, in float positiveSupport)
{
	return int(floor( (p-0.5f)+abs(positiveSupport) ));
}

void main()
{
	// assuming downscale ALWAYS, for now
	const float scale = float(pc.inWidth)/float(pc.outWidth);

	const float weight = 1.f/scale;
	const vec2 support = vec2(-0.5f*scale, 0.5f*scale);
	const uint windowDim = uint(ceil(support[1] - support[0]));
	// Todo(achal): What should happen when windowDim >= _NBL_GLSL_WORKGROUP_SIZE_, probably should put limits on the support so that it doesn't happen?
	const uint windowsPerWG = _NBL_GLSL_WORKGROUP_SIZE_/windowDim;

	// Todo(achal): This can just be a push constant
	const float maxOutputPixelCenter = ((pc.outWidth-1) + 0.5f)*scale;
	const int maxLoadIndex = getWindowMaxCoord(maxOutputPixelCenter, support.y);  // there is no point loading any texture values beyond this point, can be greater than pc.inWidth in which case we wrap

	// figure out how much of the input image we want to preload into shared memory for this workgroup
	const float firstOutputPixelCenterOfWG = ((gl_WorkGroupID.x * windowsPerWG) + 0.5f)*scale; // in input space
	const int firstLoadIndex = getWindowMinCoord(firstOutputPixelCenterOfWG, support.x); // min window coord of the first pixel, this can go negative in which case we wrap
	const float lastOutputPixelCenterOfWG = (((gl_WorkGroupID.x+1)*windowsPerWG-1u) + 0.5f)*scale;
	const int lastLoadIndex = min(maxLoadIndex, getWindowMaxCoord(lastOutputPixelCenterOfWG, support.y)); // inclusive boundary

	// elementsToLoad will ALWAYS be less than _NBL_GLSL_WORKGROUP_SIZE_, since we're computing only those output pixels whose corresponding windows COMPLETELY fit in the workgroup
	const uint elementsToLoad = lastLoadIndex-firstLoadIndex+1;

	if (gl_LocalInvocationIndex < elementsToLoad)
	{
		const int p = int(firstLoadIndex+gl_LocalInvocationIndex);
		preloadedInputPixels[gl_LocalInvocationIndex] = texelFetch(inImage, p, 0).r;
	}
	barrier();

	const uint localWindowIndex = uint(gl_LocalInvocationIndex/windowDim);
	const uint globalWindowIndex = gl_WorkGroupID.x*windowsPerWG + localWindowIndex;

	const float firstOutputPixelCenterOfWindow = (globalWindowIndex+0.5f)*scale; // globalWindowIndex maps 1-to-1 to output pixel indices
	const int windowMinIndex = getWindowMinCoord(firstOutputPixelCenterOfWindow, support.x);
	const int pixelIndex = int(windowMinIndex + (gl_LocalInvocationIndex%windowDim));

	if (globalWindowIndex < pc.outWidth)
		scratchShared[localWindowIndex*windowDim + (gl_LocalInvocationIndex%windowDim)] = preloadedInputPixels[pixelIndex - firstLoadIndex]*weight; // it is best to apply the weights here, for now, this won't fly later
	barrier();

	// Todo(achal): Gotta be careful here when windowDim becomes 1 or 0
	const uint stepCount = uint(ceil(log2(float(windowDim)))); // how many steps it would take for it to add all elements in this window
	for (uint step = 0u; step < stepCount; ++step)
	{
		const uint offset = (1 << step);
		const uint baseIndex = (1 << (step+1))*(gl_LocalInvocationIndex % windowDim);

		if ((baseIndex < windowDim) && (globalWindowIndex < pc.outWidth))
		{
			float addend = 0.f;
			if (baseIndex + offset < windowDim)
				addend = scratchShared[windowDim*localWindowIndex + (baseIndex + offset)];

			scratchShared[windowDim*localWindowIndex + baseIndex] += addend;
		}
		barrier();
	}

	// select the first invocation from a window because corresponding to that we'll have the result in scratchShared, to write to the output image
	if (((gl_LocalInvocationIndex % windowDim) == 0u) && (globalWindowIndex < pc.outWidth))
		imageStore(outImage, int(globalWindowIndex), vec4(scratchShared[gl_LocalInvocationIndex], 0.f, 0.f, 0.f));
}