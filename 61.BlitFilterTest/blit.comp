#version 450 core

layout(push_constant) uniform Block
{
	// Todo(achal): Some of these will not be needed in the future
	uint inWidth;
	uint outWidth;

	float negativeSupport;
	float positiveSupport;
	float weight;

	uint windowDim;
	uint maxLoadIndex;
} pc;


layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;

#define MAX_SMEM_SIZE (16*1024)

// Todo(achal): This should probably be a vec4
// arbitrary smem sizes
shared float preloadedInputPixels[MAX_SMEM_SIZE/8];
shared float scratchShared[MAX_SMEM_SIZE/8];

// This should most likely be a sampler
layout (set = 0, binding = 0) uniform sampler1D inImage;
layout (set = 0, binding = 1, r32f) uniform writeonly image1D outImage;

#if 0
// Todo(achal): std140??
layout (set = 0, binding = 2) uniform Weights
{
	uvec2 data[];
} weights;
#endif

// takes in input space pixel centers
int getWindowMinCoord(in float p)
{
	return int(ceil( (p-0.5f)-abs(pc.negativeSupport) ));
}

// takes in input space pixel centers
int getWindowMaxCoord(in float p)
{
	return int(floor( (p-0.5f)+abs(pc.positiveSupport) ));
}

// evaluates scaled kernel, and is temporary
float kernelEval(in float x)
{
	float result = 0.f;
	if (x > pc.negativeSupport && x < pc.positiveSupport)
		result = pc.weight;
	return result;
}

void main()
{
	// assuming downscale ALWAYS, for now
	const uint windowsPerWG = _NBL_GLSL_WORKGROUP_SIZE_/pc.windowDim;
	const float scale = float(pc.inWidth)/float(pc.outWidth);

	// figure out how much of the input image we want to preload into shared memory for this workgroup
	const float firstOutputPixelCenterOfWG = ((gl_WorkGroupID.x * windowsPerWG) + 0.5f)*scale; // in input space // 514.5
	const int firstLoadIndex = getWindowMinCoord(firstOutputPixelCenterOfWG); // min window coord of the first pixel, this can go negative in which case we wrap // 538
	const float lastOutputPixelCenterOfWG = (((gl_WorkGroupID.x+1)*windowsPerWG-1u) + 0.5f)*scale;
	const int lastLoadIndex = min(int(pc.maxLoadIndex), getWindowMaxCoord(lastOutputPixelCenterOfWG)); // inclusive boundary

	// elementsToLoad will ALWAYS be less than _NBL_GLSL_WORKGROUP_SIZE_, since we're computing only those output pixels whose corresponding windows COMPLETELY fit in the workgroup
	const uint elementsToLoad = lastLoadIndex-firstLoadIndex+1;

	if (gl_LocalInvocationIndex < elementsToLoad)
	{
		const int p = int(firstLoadIndex+gl_LocalInvocationIndex);
		preloadedInputPixels[gl_LocalInvocationIndex] = texelFetch(inImage, p, 0).r;
	}
	barrier();

	const uint localWindowIndex = uint(gl_LocalInvocationIndex/pc.windowDim); // 0
	const uint globalWindowIndex = gl_WorkGroupID.x*windowsPerWG + localWindowIndex; // 10

	const uint localPixelIndex = gl_LocalInvocationIndex % pc.windowDim; // local to a window
	const float firstOutputPixelCenterOfWindow = (globalWindowIndex+0.5f)*scale; // globalWindowIndex maps 1-to-1 to output pixel indices // 514.5
	const int windowMinIndex = getWindowMinCoord(firstOutputPixelCenterOfWindow); // this is in global input space // 490
	const int globalPixelIndex = int(windowMinIndex + localPixelIndex); // 490+[0..48]

	// firstOutputPixelCenterOfWindow + gl_LocalInvocationIndex%windowDim)

	if (globalWindowIndex < pc.outWidth)
		scratchShared[localWindowIndex*pc.windowDim + localPixelIndex] = preloadedInputPixels[globalPixelIndex - firstLoadIndex]*pc.weight; // it is best to apply the weights here, for now, this won't fly later
	barrier();

	// Todo(achal): Gotta be careful here when windowDim becomes 1 or 0
	const uint stepCount = uint(ceil(log2(float(pc.windowDim)))); // how many steps it would take for it to add all elements in this window
	for (uint step = 0u; step < stepCount; ++step)
	{
		const uint offset = (1 << step);
		const uint baseIndex = (1 << (step+1))*localPixelIndex;

		if ((baseIndex < pc.windowDim) && (globalWindowIndex < pc.outWidth))
		{
			float addend = 0.f;
			if (baseIndex + offset < pc.windowDim)
				addend = scratchShared[pc.windowDim*localWindowIndex + (baseIndex + offset)];

			scratchShared[pc.windowDim*localWindowIndex + baseIndex] += addend;
		}
		barrier();
	}

#if 0
	if ((globalWindowIndex == 10u) && (gl_LocalInvocationIndex == 0u))
	{
		imageStore(outImage, int(gl_LocalInvocationIndex), vec4(scratchShared[0], 0.f, 0.f, 0.f));
	}
#endif

	// select the first invocation from a window because corresponding to that we'll have the result in scratchShared, to write to the output image
	if ( (localPixelIndex == 0u) && (localWindowIndex < windowsPerWG) && (globalWindowIndex < pc.outWidth))
		imageStore(outImage, int(globalWindowIndex), vec4(scratchShared[gl_LocalInvocationIndex], 0.f, 0.f, 0.f));
}