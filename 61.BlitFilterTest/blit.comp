#version 450 core

#ifndef _NBL_GLSL_WORKGROUP_SIZE_X_
#error "_NBL_GLSL_WORKGROUP_SIZE_X_ is not defined"
#endif

#ifndef _NBL_GLSL_WORKGROUP_SIZE_Y_
#error "_NBL_GLSL_WORKGROUP_SIZE_Y_ is not defined"
#endif

#ifndef _NBL_GLSL_WORKGROUP_SIZE_Z_
#error "_NBL_GLSL_WORKGROUP_SIZE_Z_ is not defined"
#endif

// layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;
layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_X_, local_size_y = _NBL_GLSL_WORKGROUP_SIZE_Y_, local_size_z = _NBL_GLSL_WORKGROUP_SIZE_Z_) in;

layout(push_constant) uniform Block
{
	uvec3 inDim;
	uvec3 outDim;

	vec3 negativeSupport;
	vec3 positiveSupport;

	uvec3 windowDim;
#if 0
	// Todo(achal): Some of these will not be needed in the future
	uint inWidth;
	uint outWidth;

	float negativeSupport;
	float positiveSupport;

	uint windowDim;
#endif
} pc;


#define MAX_SMEM_SIZE (16*1024)

// Todo(achal): This should probably be a vec4
// arbitrary smem sizes
shared float scratchShared[MAX_SMEM_SIZE/8];

// This should most likely be a sampler
layout (set = 0, binding = 0) uniform sampler3D inImage;
layout (set = 0, binding = 1, r32f) uniform writeonly image3D outImage;

#if 0
// Todo(achal): std140??
layout (set = 0, binding = 2) uniform Weights
{
	uvec2 data[];
} weights;
#endif

// takes in input space pixel centers
int getWindowMinCoord(in float p)
{
	return int(ceil( (p-0.5f)-abs(pc.negativeSupport) ));
}

// takes in input space pixel centers
int getWindowMaxCoord(in float p)
{
	return int(floor( (p-0.5f)+abs(pc.positiveSupport) ));
}

#if 0
// evaluates scaled kernel, and is temporary
float kernelEval(in float x)
{
	float result = 0.f;
	if (x > pc.negativeSupport && x < pc.positiveSupport)
	{
		const float scale = float(pc.inWidth)/float(pc.outWidth);
		result = 1.f/scale;
	}
	return result;
}
#endif

void main()
{
	// assuming downscale ALWAYS, for now
	const vec3 scale = vec3(pc.inDim)/vec3(pc.outDim);

	const vec3 outputPixelCenter = (gl_WorkGroupID.xyz + vec3(0.5f, 0.5f, 0.5f))*scale;

	const ivec3 windowMinCoord = ivec3(ceil( outputPixelCenter-vec3(0.5f, 0.5f, 0.5f) - abs(pc.negativeSupport) )); // this can be negative
	const ivec3 inputPixelCoord = windowMinCoord + ivec3(gl_LocalInvocationID.xyz);

	scratchShared[gl_LocalInvocationIndex] = texelFetch(inImage, inputPixelCoord, 0).r;
	barrier();

	// filtering across X
	{
		const uint elementsToAdd = pc.windowDim.x;
		const uint stepCount = uint(ceil(log2(float(elementsToAdd)))); // how many steps it would take for it to add all elements in this window
		const uint rowStart = gl_LocalInvocationID.z*(pc.windowDim.y*pc.windowDim.x) + gl_LocalInvocationID.y*pc.windowDim.x;

		for (uint step = 0u; step < stepCount; ++step)
		{
			const uint offset = (1 << step);
			const uint baseIndex = (1 << (step+1))*(gl_LocalInvocationIndex - rowStart);

			if ((baseIndex < elementsToAdd) /*&& (globalWindowIndex < pc.outWidth)*/)
			{
				float addend = 0.f;
				if (baseIndex + offset < elementsToAdd)
					addend = scratchShared[rowStart + (baseIndex + offset)];

				scratchShared[rowStart + baseIndex] += addend;
			}
			barrier();
		}
	}

	// kernel weights for Y should be applied after filtering in X

	// filtering across Y
	{
		const uint elementsToAdd = pc.windowDim.y;
		const uint start = gl_LocalInvocationID.z*(pc.windowDim.x*pc.windowDim.y);
		const uint stepCount = uint(ceil(log2(float(elementsToAdd)))); // how many steps it would take for it to add all elements in this window
		const uint stride = pc.windowDim.x;
		for (uint step = 0u; step < stepCount; ++step)
		{
			const uint offset = (1 << step);
			const uint baseIndex = (1 << (step+1))*(gl_LocalInvocationIndex - start);

			if (baseIndex < elementsToAdd)
			{
				float addend = 0.f;
				if (baseIndex + offset < elementsToAdd)
					addend = scratchShared[start + (baseIndex+offset)*stride];

				scratchShared[start + baseIndex*stride] += addend;
			}
			barrier();
		}
	}


	// filtering across Z
	{
		const uint elementsToAdd = pc.windowDim.z;
		const uint stepCount = uint(ceil(log2(float(elementsToAdd)))); // how many steps it would take for it to add all elements in this window
		const uint start = 0u;
		const uint stride = pc.windowDim.x*pc.windowDim.y;
		for (uint step = 0u; step < stepCount; ++step)
		{
			const uint offset = (1 << step);
			const uint baseIndex = (1 << (step+1))*(gl_LocalInvocationIndex - start);

			if (baseIndex < elementsToAdd)
			{
				float addend = 0.f;
				if (baseIndex + offset < elementsToAdd)
					addend = scratchShared[start + (baseIndex+offset)*stride];

				scratchShared[start + baseIndex*stride] += addend;
			}
			barrier();
		}
	}

	if (gl_WorkGroupID.xyz == uvec3(0))
	{
		if (pc.windowDim.x*pc.windowDim.y*pc.windowDim.z*gl_LocalInvocationIndex < pc.windowDim.x*pc.windowDim.y*pc.windowDim.z)
			imageStore(outImage, ivec3(gl_LocalInvocationID.xyz), vec4(scratchShared[gl_LocalInvocationIndex*pc.windowDim.x*pc.windowDim.y*pc.windowDim.z], 0.f, 0.f, 0.f));
	}

#if 0
	const uint windowsPerWG = _NBL_GLSL_WORKGROUP_SIZE_/pc.windowDim;
	const float scale = float(pc.inWidth)/float(pc.outWidth);

	const uint localWindowIndex = uint(gl_LocalInvocationIndex/pc.windowDim);
	const uint globalWindowIndex = gl_WorkGroupID.x*windowsPerWG + localWindowIndex;

	const uint localPixelIndex = gl_LocalInvocationIndex % pc.windowDim; // local to a window
	const float outputPixelCenter = (globalWindowIndex+0.5f)*scale; // globalWindowIndex maps 1-to-1 to output pixel indices
	const int windowMinIndex = getWindowMinCoord(outputPixelCenter); // this is in global input space
	const int globalPixelIndex = int(windowMinIndex + localPixelIndex);

	const float kernelEvalPoint = (globalPixelIndex+0.5f) - outputPixelCenter;
	const float weight = kernelEval(kernelEvalPoint);

	if (globalWindowIndex < pc.outWidth)
		scratchShared[localWindowIndex*pc.windowDim + localPixelIndex] = texelFetch(inImage, globalPixelIndex, 0).r*weight;
	barrier();

	// Todo(achal): Gotta be careful here when windowDim becomes 1 or 0
	const uint stepCount = uint(ceil(log2(float(pc.windowDim)))); // how many steps it would take for it to add all elements in this window
	for (uint step = 0u; step < stepCount; ++step)
	{
		const uint offset = (1 << step);
		const uint baseIndex = (1 << (step+1))*localPixelIndex;

		if ((baseIndex < pc.windowDim) && (globalWindowIndex < pc.outWidth))
		{
			float addend = 0.f;
			if (baseIndex + offset < pc.windowDim)
				addend = scratchShared[pc.windowDim*localWindowIndex + (baseIndex + offset)];

			scratchShared[pc.windowDim*localWindowIndex + baseIndex] += addend;
		}
		barrier();
	}

	// select the first invocation from a window because corresponding to that we'll have the result in scratchShared, to write to the output image
	if ( (localPixelIndex == 0u) && (localWindowIndex < windowsPerWG) && (globalWindowIndex < pc.outWidth))
		imageStore(outImage, int(globalWindowIndex), vec4(scratchShared[gl_LocalInvocationIndex], 0.f, 0.f, 0.f));

#endif
}