#version 450 core

layout(push_constant) uniform Block
{
	// Todo(achal): Some of these will not be needed in the future
	uint inWidth;
	uint outWidth;

	float negativeSupport;
	float positiveSupport;

	uint windowDim;
} pc;

layout (local_size_x = _NBL_GLSL_WORKGROUP_SIZE_) in;

#define MAX_SMEM_SIZE (16*1024)

// Todo(achal): This should probably be a vec4
// arbitrary smem sizes
shared float scratchShared[MAX_SMEM_SIZE/8];

// This should most likely be a sampler
layout (set = 0, binding = 0) uniform sampler1D inImage;
layout (set = 0, binding = 1, r32f) uniform writeonly image1D outImage;

#if 0
// Todo(achal): std140??
layout (set = 0, binding = 2) uniform Weights
{
	uvec2 data[];
} weights;
#endif

// takes in input space pixel centers
int getWindowMinCoord(in float p)
{
	return int(ceil( (p-0.5f)-abs(pc.negativeSupport) ));
}

// takes in input space pixel centers
int getWindowMaxCoord(in float p)
{
	return int(floor( (p-0.5f)+abs(pc.positiveSupport) ));
}

// evaluates scaled kernel, and is temporary
float kernelEval(in float x)
{
	float result = 0.f;
	if (x > pc.negativeSupport && x < pc.positiveSupport)
	{
		const float scale = float(pc.inWidth)/float(pc.outWidth);
		result = 1.f/scale;
	}
	return result;
}

void main()
{
	// assuming downscale ALWAYS, for now
	const uint windowsPerWG = _NBL_GLSL_WORKGROUP_SIZE_/pc.windowDim;
	const float scale = float(pc.inWidth)/float(pc.outWidth);

	const uint localWindowIndex = uint(gl_LocalInvocationIndex/pc.windowDim);
	const uint globalWindowIndex = gl_WorkGroupID.x*windowsPerWG + localWindowIndex;

	const uint localPixelIndex = gl_LocalInvocationIndex % pc.windowDim; // local to a window
	const float outputPixelCenter = (globalWindowIndex+0.5f)*scale; // globalWindowIndex maps 1-to-1 to output pixel indices
	const int windowMinIndex = getWindowMinCoord(outputPixelCenter); // this is in global input space
	const int globalPixelIndex = int(windowMinIndex + localPixelIndex);

	const float kernelEvalPoint = (globalPixelIndex+0.5f) - outputPixelCenter;
	const float weight = kernelEval(kernelEvalPoint);

	if (globalWindowIndex < pc.outWidth)
		scratchShared[localWindowIndex*pc.windowDim + localPixelIndex] = texelFetch(inImage, globalPixelIndex, 0).r*weight;
	barrier();

	// Todo(achal): Gotta be careful here when windowDim becomes 1 or 0
	const uint stepCount = uint(ceil(log2(float(pc.windowDim)))); // how many steps it would take for it to add all elements in this window
	for (uint step = 0u; step < stepCount; ++step)
	{
		const uint offset = (1 << step);
		const uint baseIndex = (1 << (step+1))*localPixelIndex;

		if ((baseIndex < pc.windowDim) && (globalWindowIndex < pc.outWidth))
		{
			float addend = 0.f;
			if (baseIndex + offset < pc.windowDim)
				addend = scratchShared[pc.windowDim*localWindowIndex + (baseIndex + offset)];

			scratchShared[pc.windowDim*localWindowIndex + baseIndex] += addend;
		}
		barrier();
	}

	// select the first invocation from a window because corresponding to that we'll have the result in scratchShared, to write to the output image
	if ( (localPixelIndex == 0u) && (localWindowIndex < windowsPerWG) && (globalWindowIndex < pc.outWidth))
		imageStore(outImage, int(globalWindowIndex), vec4(scratchShared[gl_LocalInvocationIndex], 0.f, 0.f, 0.f));

}